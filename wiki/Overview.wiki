#summary A high-level overview of this NARS implementation
#labels Phase-Design

Open-NARS is the open-source version of NARS, a general-purpose AI system, designed in the framework of a reasoning system.

NARS works by processing tasks imposed by its environment (human users or other computer systems). Tasks can arrive at any time, and there is no restriction on their contents, as far as they can be expressed in Narsese, the I/O language of NARS (see InputOutputFormat for the Grammar of Narsese).

There are three types of tasks:
  * Judgment. To process it means to accept it as the system's belief, as well as to derive new beliefs and to revise old beliefs accordingly.
  * Question.  To process it means to find the best answer to it according to current beliefs.
  * Goal. To process it means to carry out some system operations to realize it.

As a reasoning system, the architecture of NARS consists of a memory, an inference engine, and a control mechanism. 

The memory contains a collection of concepts, a list of operators, and a buffer for new tasks. Each concept is identified by a term, and contains tasks and beliefs directly on the term, as well as links to related tasks and terms.

The inference engine carries out various type of inference, according to a set of built-in rules.

Roughly speaking, the control mechanism repeatedly carries out the _working cycle_ of the system, consisting of the following steps:
  # Select tasks in the buffer to insert into the corresponding concepts, which may include the creation of new concepts and beliefs, as well as direct processing on the tasks.
  # Select a concept from the memory, then select a task and a belief from the concept.
  # Feed the task and the belief to the inference engine to produce derived tasks.
  # Add the derived tasks into the task buffer, and send report to the environment if a task provides a best-so-far answer to an input question, or indicates the realization of an input goal.
  # Return the processed belief, task, and concept back to memory with feedback.

All the _selections_ in steps 1 and 2 are _probabilistic_, in the sense that all the items (tasks, beliefs, or concepts) within the scope of the selection have priority values attached, and the probability for each of them to be selected at the current moment is proportional to its priority value. When an new item is produced, its priority value is determined according to its parent items, as well as the type of mechanism that produces it. At step 5, the priority values of all the involved items are adjusted, according to the immediate feedback of the current cycle.

The architecture and working cycle are illustrated in http://open-nars.googlecode.com/files/architecture.pdf

At the current time, the most comprehensive description of NARS is the book  [http://www.springer.com/west/home/computer/artificial?SGWID=4-147-22-173659733-0 Rigid Flexibility: The Logic of Intelligence]. The up to date description of the logic part of the system is in [http://www.cis.temple.edu/~pwang/Writing/NAL-Specification.pdf Non-Axiomatic Logic (NAL) Specification]. The current code implements most of NAL-1 to NAL-8.

Beginners can start at the following on-line materials:
  *. The basic ideas behind the project: http://www.cis.temple.edu/~pwang/Publication/logic_intelligence.pdf
  *. The high-level engineering plan: http://www.cis.temple.edu/~pwang/Publication/roadmap.pdf
  *. The core logic: http://www.cis.temple.edu/~pwang/Publication/inheritance_nal.pdf
  *. The semantics: http://www.cis.temple.edu/~pwang/Publication/semantics.pdf
  *. The memory and control: http://www.cis.temple.edu/~pwang/Writing/computation.pdf

Additional materials:
  * The Java application/applet demonstration at http://code.google.com/p/open-nars/source/browse/#svn/trunk/nars-dist
  * The javadoc files at http://www.cis.temple.edu/~pwang/Implementation/nars-dist/javadoc/index.html
  * The example files at http://code.google.com/p/open-nars/source/browse/#svn/trunk/nars-dist/Examples